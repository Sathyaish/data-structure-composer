
// access by index
getFirst <- getByIndex
getNext <- getByIndex
getByIndex <- getFirst + n * getNext
getByIndex <- unorderedEach[_]
getLast <- getByIndex
getPrev <- getByIndex

// looping
unorderedEach[f] <- each[f]
each[f] <- unorderedEach[_] + nlogn + n * f
each[f] <- n * getByIndex + n * f
each[f] <- getFirst + n * getNext + n * f

// insertions
insertLast! <- getLast + insertAfterEndNode!
insertLast! <- insertAtIndex!
insertFirst! <- insertAtIndex!
insertFirst! <- getFirst + insertBeforeFrontNode!
insertAtIndex! <- getByIndex + insertAfterNode!
insertAtIndex! <- getByIndex + insertBeforeNode!
insertAfterNode! <- insertNextToNode!
insertBeforeNode! <- insertNextToNode!
extend! <- getLast + n * insertAfterEndNode!
insertAnywhere! <- insertAtIndex!
insertAnywhere! <- insertFirst!
insertAnywhere! <- insertLast!


// deletions
deleteAtIndex! <- getByIndex + deleteNode!
deleteFirst! <- deleteAtIndex!
deleteFirst! <- getFirst + deleteNodeWhichIsFirst!
deleteLast! <- deleteAtIndex!
deleteLast! <- getLast + deleteNodeWhichIsLast!
deleteNodeWhichIsFirst! <- deleteNode!
deleteNodeWhichIsLast! <- deleteNode!
deleteBetweenNodes! <- n * deleteNode! + n * getNext
deleteAtIndex! <- deleteBetweenNodes!

deleteFirstNodeWithValue! <- getFirstNodeWithValue[valueOrdering] + deleteNode!

// updates
updateFirstNode! <- getFirst + updateNodeWhichIsFirst!
updateNodeWhichIsFirst! <- updateNode!
updateFirstNode! <- deleteFirst! + insertAfterFrontNode!

updateLastNode! <- getLast + updateNodeWhichIsLast!
updateNodeWhichIsLast! <- updateNode!
updateLastNode! <- deleteLast! + insertAfterEndNode!

updateByIndex! <- deleteAtIndex! + insertNextToNode!
updateByIndex! <- getByIndex + updateNode!

// stuff about orderings by values
quickSelect[f] <- unorderedEach[f]
getKthBy[f] <- quickSelect[f]
getFirstBy[f] <- reduce[_{commutative, idempotent} <- f]
getFirstBy[f] <- getKthBy[f]
getLastBy[f] <- reduce[_{commutative, idempotent} <- f]
getLastBy[f] <- getKthBy[f]
countBetweenBy[f] <- unorderedEach[f]
getMaximum <- getFirstBy[valueOrdering]
getMaximum <- getLastBy[valueOrdering]
getMinimum <- getLastBy[valueOrdering]
getMinimum <- getFirstBy[valueOrdering]
deleteFirstBy![f] <- getFirstBy[f] + deleteNode!
deleteLastBy![f] <- getLastBy[f] + deleteNode!
deleteSmallest! <- deleteFirstBy![valueOrdering]
deleteBiggest! <- deleteLastBy![valueOrdering]
getFirstNodeWithValue[f] <- unorderedEach[f]
// The obvious implementation for getNearest is to just loop over everything
getNearest[f] <- unorderedEach[f]
// using binary search:
getNearest[f] <- log(n) * getKthBy[f]

// other reductions
count <- unorderedEach[_]
contains <- count
contains <- getFirstNodeWithValue[f]
select[f] <- unorderedEach[f]
reduce[f] <- each[f]
reduce[f] if f.commutative <- unorderedEach[f]

count <- countOfEquivalenceClass[_]
countOfEquivalenceClass[f] <- unorderedEach[f]
mostNumerousEquivalenceClass[f] <- unorderedEach[f]
mostCommonElement <- mostNumerousEquivalenceClass[_]

// eg, querying for the sum of the elements between indexes i and j
twoSidedIndexRangeQuery[reduction] <- unorderedEach[reduction]

// eg, querying for the sum of the elements between index 0 and index i
oneSidedIndexRangeQuery[reduction] <- unorderedEach[reduction]
oneSidedIndexRangeQuery[reduction] <- twoSidedIndexRangeQuery[reduction]
rangeMinimumQuery <- twoSidedIndexRangeQuery[_{idempotent}]

// eg, querying for the number of elements whose values are in the range (a, b)
twoSidedValueRangeQuery[f, reduction] <- unorderedEach[_ <- f + reduction]
// eg, querying for the sum of the k smallest elements
oneSidedValueRangeQuery[f, reduction] <- unorderedEach[_ <- f + reduction]
oneSidedValueRangeQuery[f, reduction] <- twoSidedValueRangeQuery[f, reduction]

valueOrdering <- 1

getSum <- reduce[_{commutative, invertible} <- 1]
