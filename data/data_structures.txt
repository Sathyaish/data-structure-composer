
ds VectorList {
    getByIndex <- 1
    updateNode! <- 1
    insertLast! <- 1
    deleteAtIndex! <- n
    deleteBetweenNodes! <- n
    deleteLast! <- 1
}

ds RedBlackOrderStatisticTreeList {
    getByIndex <- log(n)
    updateNode! <- log(n)
    getNext <- 1
    getPrev <- 1
    insertLast! <- 1
    insertAfterNode! <- 1
    insertFirst! <- 1
    deleteNode! <- log(n)
    deleteBetweenNodes! <- log(n)
}

ds AugmentedRedBlackOrderStatisticTreeList[g] {
    getByIndex <- log(n)
    updateNode! <- log(n)
    getNext <- 1
    getPrev <- 1
    insertLast! <- log(n)
    insertAfterNode! <- log(n)
    insertFirst! <- log(n)
    deleteNode! <- log(n)
    deleteBetweenNodes! <- log(n)
    twoSidedIndexRangeQuery[g] <- log(n)
}

ds StackMemoizer[reduction] if reduction.idempotent {
    insertLast! <- 1
    deleteLast! <- 1
    reduce[reduction] <- 1
}

ds Heap[heapOrdering] {
    unorderedEach <- n
    getFirstBy[heapOrdering] <- 1
    deleteNode! <- log(n)
    updateNode! <- log(n)
    insertAtIndex! <- log(n)
}

ds OrderedRedBlackTree[f, g] {
    unorderedEach <- n
    getNext <- 1
    getPrev <- 1
    getFirst <- 1
    getLast <- 1
    updateNode! <- 1
    getFirstBy[f] <- 1
    getLastBy[f] <- 1
    getKthBy[f] <- log(n)
    insertAtIndex! <- log(n)
    getFirstNodeWithValue[f] <- log(n)
    deleteNode! <- 1
    countBetweenBy[f] <- log(n)
    twoSidedValueRangeQuery[g] <- log(n)
    oneSidedValueRangeQuery[g] <- log(n)
}

ds RangeMinQueryLinearithmicArrayThing[reduction] if reduction.idempotent {
    twoSidedIndexRangeQuery[reduction] <- 1 + reduction
    insertLast! <- log(n)
    deleteLast! <- 1
}

ds HistogramHashMap[groupingFunction] {
    countOfEquivalenceClass[groupingFunction] <- 1
    insertAtIndex! <- 1
    updateNode! <- 1
    deleteAtIndex! <- 1
}

ds InvertibleReductionMemoizer[f] if f.invertible, f.commutative {
    reduce[f] <- 1
    insertAtIndex! <- 1
    updateNode! <- 1 + getByIndex
    deleteNode! <- 1 + getByIndex
}

