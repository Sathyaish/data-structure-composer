
Array {
    getByIndex <- 1
    deleteAtIndex! <- n
    deleteBetweenNodes! <- n
    deleteAtEnd! <- 1
    updateNode! <- 1
}

VectorList {
    getByIndex <- 1
    updateNode! <- 1
    insertAtEnd! <- 1
    deleteAtIndex! <- n
    deleteBetweenNodes! <- n
    deleteAtEnd! <- 1
}

InvertibleMonoidMemoizer[f] if f.invertible {
    reduce[f] <- 1
    insertAtEnd! <- f
    insertAtFront! <- f
    insertNextToNode! if f.commutative <- f
}

StackMemoizer[f] {
    insertAtEnd! <- f
    reduce[f] <- 1
    oneSidedRangeQuery[f] <- 1
}

InvertibleSquareRootBlocks[f] if f.invertible {
    insertAtEnd! <- 1
    updateNode! <- 1
    twoSidedRangeQuery[f] <- sqrt(n)
}

SquareRootBlocks[f] {
    insertAtEnd! <- 1
    updateNode! <- sqrt(n)
    twoSidedRangeQuery[f] <- sqrt(n)
}

RedBlackTreeList[f] {
    getByIndex <- log(n)
    getNext <- 1
    getPrev <- 1
    insertNextToNode! <- 1 + f
    updateNode! <- 1
    // check this
    deleteNode! <- 1 + f
    deleteBetweenNodes! <- log(n) * (1 + f)
    arbitraryRangeQuery[f] <- log(n)
    extend! <- n
    oneSidedIndexRangeQuery[f] <- log(n)
    twoSidedIndexRangeQuery[f] <- log(n)

}

// ordered by f, memoizing reductions on g
OrderedRedBlackTree[f, g] {
    unorderedEach <- n
    getNext <- 1
    getPrev <- 1
    getFirst <- 1
    getLast <- 1
    updateNode! <- 1 + g
    findFirstBy[f] <- 1
    findLastBy[f] <- 1
    findKthBy[f] <- log(n)
    insertAtIndex! <- log(n) + g
    getFirstNodeWithValue[f] <- log(n)
    deleteNode! <- 1 + g
    countBetweenBy[f] <- log(n)
    twoSidedValueRangeQuery[g] <- g * log(n)
    oneSidedValueRangeQuery[g] <- g * log(n)
}

HistogramHash[f] {
    updateNode! <- f
    unorderedEach <- n
    insertAtIndex! <- f
    deleteNode! <- f
    countOfEquivalenceClass[f] <- 1
}

// I'm not sure what this data structure is
SizeOrderedHistogramTree[f] {
    insertByIndex! <- log(n) + f
    deleteNode! <- 1
    countOfEquivalenceClass[f] <- log(n)
    mostNumerousEquivalenceClass[f] <- 1
}

SparseArrayForIdempotentRangeQuery[f] if f.idempotent {
    insertAtEnd! <- f * log(n)
    indexRangeQuery[f] <- 1
}

FischerHeunStructure[f] if f.idempotent {
    extend! <- n
    indexRangeQuery[f] <- 1
}

Heap[f] {
    unorderedEach <- n
    findFirstBy[f] <- 1
    deleteNode! <- log(n)
    insertAtIndex! <- 1
}
